<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2019%2F03%2F22%2Fgo%2F</url>
    <content type="text"><![CDATA[测试 艾迪康发生率的恐惧的咖啡金阿斯顿浪费快圣诞节安防]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react and vue summary]]></title>
    <url>%2F2019%2F03%2F21%2Freact-and-vue-summary%2F</url>
    <content type="text"><![CDATA[前言 俗话说的好，好记忆不如烂键盘；所以博主就把自己理解的或者别人总结的东西放到这里 React理解总结笔记语法1、自定义组件名首字母必须大写 组件如何编写组件1、ES5编写JSX 123456789var HelloMessage = React.createClass(&#123; render:function()&#123; return( &lt;div&gt; Hello, world! &lt;/div&gt; ) &#125; &#125;) 2、ES6语法编写JSX 12345678910import React from 'react';class HelloMessage extends React.Component &#123; render () &#123; return ( &lt;div&gt; Hello, world! &lt;/div&gt; ) &#125;&#125; 生命周期1、构造函数 构造函数，在创建组件的时候调用一次。 1constructor(props, context) 2、渲染前1void componentWillMount() 3、渲染完成后1void componentDidMount() 4、组件挂载之后加载1void componentWillReceiveProps(nextProps) 5、组件状态被修改前1void componentWillUpdate(nextProps, nextState) 6、组件被修改完成之后1void componentDidUpdate() 7、组件被销毁前1void componentWillUnmount() 8、是否需要渲染 组件挂载之后，每次调用setState后都会调用shouldComponentUpdate判断是否需要重新渲染组件。默认返回true，需要重新render。在比较复杂的应用里，有一些数据的改变并不影响界面展示，可以在这里做判断，优化渲染效率。 1bool shouldComponentUpdate(nextProps, nextState) 更新方式 在react中，触发render的有4条路径。 1、首次渲染Initial Render2、调用this.setState （并不是一次setState会触发一次render，React可能会合并操作，再一次性进行render）3、父组件发生更新（一般就是props发生改变，但是就算props没有改变或者父子组件之间没有数据交换也会触发render）4、调用this.forceUpdate 如图： state 个人认为，state一般存在于父组件或者自身需要即时获取用户状态的情况下使用，state在组件中是越少越好 props 个人认为，props一般存在于子组件，父组件的state数据变化传递给子组件作为props来更新视图，而且不可被改变 state和props的关系 Props and state are related. The state of one component will often become the props of a child component.Props are passed to the child within the render method of the parent as the second argument to React.createElement() or, if you’re using JSX, the more familiar tag attributes.属性和状态是有联系的。通常，一个组件的state会变成另一个组件的props,子组件的render函数会被props传递给React.createElement()的第二个参数，或者你使用jsx会变成其他属性 1&lt;MyChild name=&#123;this.state.childsName&#125; /&gt; The parent’s state value of childsName becomes the child’s this.props.name. From the child’s perspective, the name prop is immutable. If it needs to be changed, the parent should &gt; just change its internal state:父组件的state.childsName会变成子组件的属性this.props.name,子组件的props是不能被改变的。如果需要改变，父组件需要改变它的内部state 1this.setState(&#123; childsName: 'New name' &#125;); and React will propagate it to the child for you. A natural follow-on question is: what if the child needs to change its name prop? This is usually done through child events and &gt; parent callbacks. The child might expose an event called, for example, onNameChanged. The parent would then subscribe to the event by passing a callback handler.然后React会传递给子组件给用户，那么问题来了：子组件如何改变属性状态？这通常需要通过子组件的事件和父组件的回调来完成。子组件需要暴露一个事件名称，举个例子，父组件将会订阅回调事件onNameChanged 1&lt;MyChild name=&#123;this.state.childsName&#125; onNameChanged=&#123;this.handleName&#125; /&gt; The child would pass its requested new name as an argument to the event callback by calling, e.g., this.props.onNameChanged(‘New name’), and the parent would use the name in the &gt; event handler to update its state.子组件将会通过请求一个新的名称作为参数提交给事件回调，举个例子this.props.onNameChanged(&#39;New name&#39;)，在父组件将会用这个新的名称来更新state 123handleName: function(newName) &#123; this.setState(&#123; childsName: newName &#125;);&#125; Vue理解总结笔记]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Vue</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how-display-contents-works]]></title>
    <url>%2F2018%2F03%2F29%2Fhow-display-contents-works%2F</url>
    <content type="text"><![CDATA[As I frequently mention, every element in the document tree is a rectangular box。Broadly speaking, this “rectangular box” consists of two sections. First we have the actual box, which consists of the border, padding, and margin areas. Second, we have the contentsof the box; the content area. With the CSS display property, we can control different things about how this box and its children are drawn on the page. We can have the box be placed within its siblings like text with inline. We can even trick the box into behaving like a table with table. There are only two values for the display property which control whether an element defined in the markup will generate a box at all. The none value will result in neither the box or its contentsbeing drawn on the page. The newly specced contentsvalue, on the other hand, will result in the contentsof the box being drawn as normal, but the surrounding box being omitted entirely. What happens when you use display: contents?The easiest way to understand what happens when display: contents is used is to imagine the element’s opening and closing tags being omitted from the markup. In the specification, it states - For the purposes of box generation and layout, the element must be treated as if it had been replaced in the element tree by its contents Let’s take, for example, the following markup - 1234&lt;div class="outer"&gt; I’m some content &lt;div class="inner"&gt;I’m some inner content&lt;/div&gt;&lt;/div&gt; And the following styles - 12345678910.outer &#123; border: 2px solid lightcoral; background-color: lightpink; padding: 20px;&#125;.inner &#123; background-color: #ffdb3a; padding: 20px;&#125; Typically, this is how we would expect the elements to be drawn on the page - However, if we add display: contents to the .outer element, this is how it is displayed - Visually speaking, the above result is exactly the same as what we would expect if the markup was written without the opening and closing tags of the outer element. 12I’m some content&lt;div class="inner"&gt;I’m some inner content&lt;/div&gt; What about…?This CSS rule, although seemingly straightforward, has quite a few edge cases and specific behaviours to take note of. We have to remember that the display: contents rule only affects the box being visually drawn on the page; it does not affect the markup within the document. What about the element’s attributes?If the element is effectively replaced by its contents, what does that mean for any attributes applied to it? Since this replacement is, for the most part, visual only, we can actually still select, target, and interact with the element using its attributes. We can still target the element by its ID by, for example, making a reference to it using aria-labelledby. 12&lt;div id="label" style="`display: contents `;"&gt;Label here!&lt;/div&gt;&lt;button aria-labelledby="label"&gt;&lt;button&gt; However, the one thing I have found that doesn’t work properly is that we can no longer navigate to the element using a fragment identifier. 123456&lt;div id="target" style="display: contents ;"&gt;Target Content&lt;/div&gt;&lt;script&gt; window.location.hash = "target"; // =&gt; Nothing happens&lt;/script&gt; What about JavaScript events?As we have just covered, we can still target an element with display: contents applied to it. In fact, we can target an element with display: none applied, but the event will never trigger because we cannot interact with the element. However, since the contents of an element with display: contents are still visible, we can interact with the element through its contents. If we set an event listener for a click on the element, for example, and log the value of this, we will still get the outer element because it still exists in the document. 12345678&lt;div class="outer"&gt;I’m some content&lt;/div&gt;&lt;script&gt; document.querySelector(".outer").addEventListener("click", function(event) &#123; console.log(this); // =&gt; &lt;div class="outer"&gt;&lt;/div&gt; &#125;);&lt;/script&gt; What about pseudo-elements?The pseudo-elements of an element with display: contents are considered to be part of its children, so are displayed as normal. 1234567&lt;style&gt; .outer &#123; `display: contents `; &#125; .outer::before &#123; content: "Before" &#125; .outer::after &#123; content: "After" &#125;&lt;/style&gt;&lt;div class="outer"&gt;I’m some content&lt;/div&gt; The above markup will generate the following result - What about form elements, images and other replaced elements?Replaced elements and some form elements have a different behaviour when display: contents is applied to them. Replaced elementsReplaced elements are elements, such as images, whose appearance and “boxes” are controlled by an external resource. Attempting to remove the box for elements like this doesn’t really make sense because it isn’t entirely clear what the “box” is. For these elements, display: contents functions exactly like display: none. The entire box and contents of the element are not drawn on the page at all. Form elementsFor many form elements, they are not composed of a single “box”. They look like that from the perspective of us, the web page authors. But under the hood, they are made up of several smaller elements. Similarly to the replaced elements, it doesn’t make sense to remove the box, because there isn’t one box. And so, for form elements like &lt;select&gt;, &lt;input&gt;, and &lt;textarea&gt;, display: contents functions exactly like display: none. See the full list of elements that display: contents works differenly for What about buttons and links?Both the &lt;button&gt; and &lt;a&gt; elements do not have any special behaviour when it comes to display: contents. However, it is useful to know how this rule affects them because it may not be immediately obvious. ButtonsButtons are not one of the form elements which are composed of other boxes. Therefore, display: contents will just remove the surrounding box, leaving the content of the button displayed. If used within a form, clicking the button will still attempt to submit the form and, as we have covered, any event listeners on the button will function normally. LinksFor links, the same applies in that the surrounding box is visually removed, leaving the contents of the link behind. Since attributes aren’t generally affected by this CSS rule, the link will still function properly and can be used to navigate as normal. Why is display: contents useful?In the past, we have had to lay out our HTML in a way that works both semantically, and for the purposes of styling with CSS. This has led to cases where we either have too many unnecessary elements for wrapping purposes, or too few elements to enable direct sibling styling. The latter has become particularly pertinent with the introduction of CSS Grid Layout which, for now at least, needs to work with direct sibling elements. Let’s take, for example, this layout - We have two “cards” placed next to each other, each with a heading, a pargraph, and a footer. What we want is for each of the sections within each card to be the same height, regardless of the content of each section (e.g. the first card has only a 1-line whereas the third card has a 3-line heading, but the first card heading section height should match the third). We could achieve this layout using CSS Grid, but we would need all the elements within each “card” to be direct siblings of each other. So, we may have to layout our HTML like this - 123456789&lt;div class="grid"&gt; &lt;h2&gt;This is a heading&lt;/h2&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;Footer stuff&lt;/p&gt; &lt;h2&gt;This is a really really really super duper loooong heading&lt;/h2&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;Footer stuff&lt;/p&gt;&lt;/div&gt; And we could apply the following styles - 1234567.grid &#123; display: grid; grid-auto-flow: column; grid-template-rows: auto 1fr auto; grid-template-columns: repeat(2, 1fr); grid-column-gap: 20px;&#125; Although this is not exactly an incorrect way to structure this document, it probably makes more sense to group each “card” within an &lt;article&gt; element. This is where display: contents comes in. We can have the best of both worlds here - by laying out our markup in a way that makes sense semantically, but having our CSS act in a way that makes sense layout-wise. 123456789101112&lt;div class="grid"&gt; &lt;article style="display: contents;"&gt; &lt;h2&gt;This is a heading&lt;/h2&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;Footer stuff&lt;/p&gt; &lt;/article&gt; &lt;article style="display: contents;"&gt; &lt;h2&gt;This is a really really really super duper loooong heading&lt;/h2&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;Footer stuff&lt;/p&gt; &lt;/article&gt;&lt;/div&gt; With the same CSS as above, we can achieve the layout we want. Using display: contentsAt the time of writing, display: contents is only supported in two major browsers, with support arriving soon in many others. Because of this, this feature should still currently be considered a progressive enhancement, and an appropriate fallback should be used. 12345678article &#123; display: grid; grid-template-rows: 200px 1fr auto; /* e.g. Use a fixed height for the header */&#125;@supports (display: contents) &#123; article &#123; display: contents; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[这七种迹象，暗示你的生活正慢慢变好]]></title>
    <url>%2F2017%2F12%2F08%2F%E8%BF%99%E4%B8%83%E7%A7%8D%E8%BF%B9%E8%B1%A1%EF%BC%8C%E6%9A%97%E7%A4%BA%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB%E6%AD%A3%E6%85%A2%E6%85%A2%E5%8F%98%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[转眼，离2017年的结束只有24天。 有人调侃：“我2018年的新计划，就是完成2017年计划的、一定要做完的、2016年没做完的事情。” 年底事务繁忙，不少人因为忙得底朝天而陷入无尽焦虑：新的一年会更好吗？ 《这个杀手不太冷》里，玛蒂达问，人生总是那么痛苦吗？还是只有小时候这样。 里昂回答说，总是如此。 真实的人生其实不尽然，看起来人人都离不开烦恼的旋涡，但一些迹象已经表明，生活正在慢慢变好。 △ 一、学会规划时间有些发明，初衷是为了节省时间提高效率，最后却占用了越来越多的时间。 比如购物APP，比如资讯APP。 拿起手机打开购物软件逛一逛，刷刷微博看看新鲜事，10点上床准备睡觉，结果刷到了半夜。 某宝提供的物品太多，你陷入选择困难症。微博娱乐信息太多，明星离婚出轨的消息看不够。 讯息接受超过一定程度，人就容易陷入焦虑。 花了太多时间在这些海量信息中流连忘返，产生了一种每天都能从中获取很多知识的错觉。 某天醒来才发现，其实看过的东西，你一件也想不起来。 无意识地刷手机，不过是为了转移注意力，逃避眼前要做的事。但最终，人还是要为那些悄悄流走的时间买单。 想让生活慢慢变好，必须尽量去摆脱那些无聊的娱乐八卦。 知乎上有个话题：“是什么一下子结束了你的长期拖延？” 有这样一个匿名回答： “突然有一天睡梦中惊醒，今年我已经30岁了，如果我再不努力，这辈子也就这样了。以前因为不懂事，变成了现在的我，过着现在的生活。但是如果因为以前的不懂事，我的后半辈子都得为此买单，我不甘心。” 有意识地控制自己，不再漫无目地耗时间，说明你已经开始学会控制自己，规划时间。 △ 二、找准了前进方向“不喜欢眼前的，但又不知道自己到底喜欢什么”，是最具普遍性的迷茫。 许多人思考了许多年，还是没有想通透，于是一边寻找，一边妥协，将就了自己。 看《奇葩大会》的时候，有位叫刘楠的CEO让人印象深刻。 她职场生涯的前半段，和许多人类似：名校毕业，进了外企，做了白领。 但刘楠感觉自己不快乐。 “天天做PPT，做汇报”，她深知自己不喜欢这种流程化的工作。每天重复性地劳动，让她感到恐慌，于是她辞职了。 生完孩子后，她开始创业。 “为什么我要创业？我希望生活在自己想生活的世界里，但是可能等不及别人来创造这个世界，所以我就自己去做这个世界。“ 她清楚自己不想要什么，在还有勇气的时候，敢以“试错”的方式来确定人生。 无印良品的社长松井忠三曾说：“面对工作，若只像少年棒球队的孩子一样，笼统地抱持着我要努力的心态，是最糟糕的。” 因为努力的前提是，你已经找准了方向。 之所以犹豫，如果不是因为不勇敢，就是因为还不知道自己想要什么。 所以当有一天面对选择时，你不再踟蹰不定，那一定是生活变好的信号。 △ 三、懂得照顾自己近年来，都市年轻人过劳猝死的新闻层出不穷。 很多人彻夜不眠地努力，痴痴地相信“没有经历通宵的奋斗不是人生”，以“见过凌晨四点的公司”为荣。 数据显示，白领阶层中工作时间超过8小时的高达60%，10小时以上的占25%，超过12小时的占15%，而他们的每周平均锻炼时间不超过3小时。 工作都很拼，会好好照顾自己的没几个。 不吃早饭，没时间就啃个面包，外卖方便面是首选。 但工作努力和照顾自己，不完全冲突。 今年9月，网友@卡卡Prancil 在微博分享自己的经历。 9月2日的早晨，博主在毫无预兆的情况下后脑勺剧烈疼痛，并冷汗直流。 被送往医院之后，ct扫描结果显示博主脑内多处出血。之后9天，他每天打20多瓶药，止血、吸收水肿、冲脑，几乎吃什么都会引起呕吐，吐到黄胆水都出来。 博主在自述最后，给出了3点忠告： 1.一定要规律作息，朝六晚十。我长期熬夜到1点多才睡，第二天又早早起来工作。熬夜的伤害其实长期潜伏在你身体里，你永远都不知道什么时候会爆发。 2.调节工作/学习压力。可能因为在工作上越来越给力，收入越来越高，所以越来越忙。我想到的也只是尽力去做好，终于把身体给拖垮了。大家一定要权衡，量力而行。 3.一定要多多运动，不能老是躺着。医生说我的血管太脆弱了，没有弹性，长期缺乏运动。无论是怎么样的运动，一定要动起来。 算起来，坚持这些，并不需要花费太多时间。坚持按点吃饭，每天锻炼身体，清晨的粥总比深夜的酒好喝。 身体不行的人，是走不到最后的。 △ 四、对生活的人和事更加包容活到一定岁数，渐渐发现，人人都有自己的难处。 韩剧《请回答1988》里，德善奶奶去世后，德善看到爸爸和姑姑们没有流一滴眼泪，觉得大人们太冷血。直到所有人散场后，她看到爸爸和姑姑们放声大哭。 成年人那些真心的难过，都是背着人群偷偷流泪。 很多时候，片面的批评与责备，是不理解导致的不宽容。 “一个人真正成熟的标志，就是发觉可以责怪的人越来越少。理由很简单，人人都有自己的难处，而你，不一定懂得他们的生活。”作家亦舒说。 年初，有网友在微博中晒出了一张外卖订单，备注内容是：“送餐小哥，我没那么着急吃饭，送餐路上请安全第一。如果超时可提前按已送达，或与我联系。辛苦了，谢谢你……” 记者采访这位网友时，她表示，看了“外卖小哥送餐超时，电梯里急哭”的视频后，她很有感触。 “如果不是因为职业态度问题，外卖小哥送餐迟到是可以体谅的。因为各个外卖平台都有详细的送餐规则，确实也没必要破坏，毕竟无规矩不成方圆。但是，我愿意在力所能及的范围内给送餐员一些方便和温暖。” 越包容，自己的生活越好过，越计较，自己的空间就越小。苛责怨恨别人，往往会使自己失去了快乐。 与其说包容是给别人尊重和理解，不如说，也是为了自己顺心。 △ 五、有一两样自己的爱好无论多忙，年纪多大，依然葆有对生活的热爱和探索欲。 在重庆标志性建筑国泰艺术中心，曾举办过一场大提琴演奏会。 这场演奏会很特别，因为台上的演奏员一半以上都不是专业的大提琴演奏者，她们有不同的职业：警察、设计师、会计、记者、画家、全职主妇…… “我的第一个学员是一名警花，当她找到我时，我半晌没有回过神来，她的工作不是和大提琴风马牛不相及吗？”大提琴老师说，“但这名学员执意要学，警察的工作纪律性很强，强度也大，学员说，只要她一坐下来，搭弓拉弦，她觉得心一下子静了，整个纷扰世界都在琴声之外。” 这些大提琴爱好者们，在原本非常忙碌的工作生活中，靠着一股子热爱和学习欲，把兴趣变成了一项技能。 有人说，自己好像对所有事儿都提不起兴趣。 问题的关键或许在于，过于追求事物带来的成就感，或者追求快速的成功。 更好的解决方法是，学会享受做这件事的过程中，带给你的愉悦感和活力。 对甜点感兴趣，就去买烤箱买黄油买馅料，再买本精致的食谱；对潜水感兴趣，可以趁着假期去海边，试着考个潜水证；对摄影感兴趣，就多带着相机出去，走走拍拍。 最重要的，不是烤出一个多么美味的蛋糕，或者成为潜水专家、摄影师，而是挖掘自己的兴趣，让日子变得快乐充实。 △ 六、有一两个要好的朋友美剧《老友记》还有个名字叫“六人行”，只有六个人，彼此交好。 他们也想过寻找新朋友，但相处得都不顺利。 朋友不用太多，知己一二就好。 穿梭于酒桌饭局的酒肉兄弟，朋友圈从不走心的点赞之交，让人愈发觉得一段纯粹的友谊是人生的确幸。 在《我们的友谊，最终死在了朋友圈》一文后台，有读者谈到了她和好朋友之间的故事： 和闺蜜两人都在北京打拼，一个在北五环，一个在南四环，相隔太远，工作太忙，所以见面不多。那天夜晚北京大雪，她失恋了，发了条朋友圈，没想到闺蜜在深夜冒着大雪，带着热腾腾的馄饨过来安慰她，照顾她。 “那一瞬间，觉得有这样的朋友，有什么槛儿是过不去的呢。” 就如同亦舒说的：“那种难得的朋友。我成功，她不嫉妒。我委靡，她不轻视。人生得一知己足矣。” 有这样的兄弟闺蜜，缺钱，说一声，借你；喝酒，打个电话，陪你。 也不用在彼此面前逞强，不用担心因为长期不联系感情会变淡。 他们的存在，让你就算在人生低谷，也依然相信一切都会慢慢变好。 △ 七、不再过分攀比以前总羡慕别人过得有多好，总是追着别人跑，跑着跑着把自己跑丢了。 68岁退休老教授在《牛蛙之殇》一文中，讲了他在研究所为祖国的科研事业辛苦了一辈子，本以为退休后可以含饴弄孙，却因为孙子的教育问题遭遇了“滑铁卢”。 小孙子从幼儿园开始，就被安排去上昂贵又严格的私立幼儿园，只为保证他从小有一口流利的英语，能在未来的入学面试时保有竞争力，读到最好的小学。 但孙子落榜了。从此，教授一家陷入了入学失败的痛苦深渊。 因为邻居家的孩子都顺利进入“名校”，原本在邻里之间较为优越的教授家，变得矮人一头。 为了争口气，孩子他妈想要孩子晚一年上学，明年再考一次。 人的一生如同一场战役，不到闭上眼睛那一天，炮火不会终结。 身心俱疲就为了处处超越别人，如同田忌赛马，眼里只有自己的下等马和对方的上等马。但实际上，你也有长处，对方也有短板。 躺着刷朋友圈，看到不如自己漂亮能干的同学天天在国外旅游度假，不由感叹：“嫁个有钱老公真好！”于是跟丈夫一顿大吵，厉声埋怨； 前任找到了新女友，于是不停地刷微博和朋友圈，不想看又忍不住，经常一刷就是好几个小时，啥也没干成。 窥探别人的生活、别人的思想，然后与自己作比较，满眼是自己与他人的差距，无法感到快乐。 但别人的生活终究是别人的，与其在别人身上浪费不必要的时间，还不如先把自己的过好。 把分散在牛人身上的目光，多聚焦在自己身上，每天都进步一点点，足够了。 改变每天常在 最近看《演员的诞生》，凌潇肃和蓝盈莹的表演非常亮眼，两人都深得评委认可。 但当很多专业评审更倾向于凌潇肃时，章子怡把关键的一票投给了蓝盈莹，原因是凌潇肃是80年生人，蓝盈莹整整小了他十岁。 “十年有十年的经验。”她说。 言外之意，每大一岁，都会给一个人带来经历和成长。时间流逝无痕迹，又把成长深深刻在你的骨子里。 现在的自己，如果和一年前的自己有些许不同，那过去的日子就算没白过。 经常听到有人问：“有没有什么事，彻底改变了你的一生？” 很多人会提供很多惊心动魄的回答，仿佛就是那个电光火石的瞬间，彻底改造了自己。 但其实，生命里的每一件琐细之事都将作用于我。昨日种种，今日结果；今日所行，明日所得。 吃饱了，是因为吃了三个馒头，而不是第三个馒头。压死骆驼的是所有的稻草，不是最后一根。 同样，让生活越来越好的，也不会是某个瞬间，而是蛰伏在平淡中的每一个日常。 愿你2018年的生活越来越好，愿2018年槽值仍旧与你相伴。 作者：槽值 链接：http://www.jianshu.com/p/cc5fa0308b92 來源：简书]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jquery-wechat-sdk-api]]></title>
    <url>%2F2017%2F11%2F15%2Fjquery-wechat-sdk-api%2F</url>
    <content type="text"><![CDATA[依赖模块1234$ npm install jqyery$ npm install weixin-js-sdk 简介 一个基于jquery的兼容AMD、CMD、Commandjs的模块包，目的在于帮助微信开发者更好的更方便的使用微信里面的api。 快速上手简单加载导入资源 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;script src="https://res.wx.qq.com/open/js/jweixin-1.0.0.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha256-k2WSCIexGzOj3Euiig+TlR8gA0EmPjuc79OEeY5L45g=" crossorigin="anonymous"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://blog.xulayen.com/cdn/jquery_wechat_sdk.1.4.9.js"&gt;&lt;/script&gt; &lt;script&gt; console.log($.WeChart(&#123; appId: 'your appid', timestamp: 'your timestamp', nonceStr: 'your nonceStr', signature: 'your signature ', access_token:'your access_token', debug:true &#125;).InitWeChat()); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 1、调取api地址远程获取123456789101112131415161718var _w = require('jquery_wechat_sdk');var params=&#123; api:'', debug:false yourdata:yourdata&#125;var wechatMgr=_w.WeChart(params);wechatMgr.InitWeChat(function(result)&#123; this.appId = result.appid; this.timestamp = result.timestamp; this.nonceStr = result.nonceStr; this.signature = result.signature; this.access_token = result.access_token;&#125;); 2、本地直接设置1234567891011var _w = require('jquery_wechat_sdk');var wechatMgr= _w.WeChart(&#123; appId: 'your appid', timestamp: 'your timestamp', nonceStr: 'your nonceStr', signature: 'your signature ', access_token:'your access_token'&#125;).InitWeChat(); 入门篇环境准备准备基础环境 browserify ，基础浏览器一枚，可以在开源项目中学习在browserify中加载jquery_wechat_sdk 安装1234$ npm install browserify --save-dev$ npm install jquery_wechat_sdk --save-dev 使用Browserify/Webpackbrowserify API / Webpack API猛击源码获取项目demo 12345678910111213var _w = require('jquery_wechat_sdk');var wechatMgr=_w.WeChart(&#123; appId: 'your appid', timestamp: 'your timestamp', nonceStr: 'your nonceStr', signature: 'your signature ', access_token:'your access_token', debug:true&#125;);wechatMgr.InitWeChat(); AMD (Asynchronous Module Definition)AMD 是为浏览器创建的模块，更多信息参见，这里推荐使用require.js文档 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;script src="http://res.wx.qq.com/open/js/jweixin-1.0.0.js" type="text/javascript" &gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.5/require.js" type="text/javascript" &gt;&lt;/script&gt; &lt;script&gt; require.config(&#123; baseUrl: "./static", paths: &#123; "jquery_wechat_sdk":"jquery_wechat_sdk" &#125; &#125;); require(['jquery_wechat_sdk'],function(_w)&#123; _w.WeChart(&#123; appId: 'your appid', timestamp: 'your timestamp', nonceStr: 'your nonceStr', signature: 'your signature ', access_token:'your access_token', debug:true &#125;).InitWeChat(); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; BabelBabel是下一代JavaScript编译器。其中一个特性是现在可以使用ES6/ES2015模块，尽管浏览器还没有本地支持这个特性。 1import _w from "jquery_wechat_sdk"; Nodejquery_wechat_sdk运行在node端，需要提供一个带有document的window，因为没有这样的document在node中存在，所以可以使用jsdom,这样可以达到测试的目的 1npm install jquery_wechat_sdk 12345678require("jsdom").env("", function(err, window) &#123; if (err) &#123; console.error(err); return; &#125; var _w = require("jquery_wechat_sdk")(window);&#125;); 进阶篇微信菜单.InitWeChat()api默认隐藏所有的微信功能菜单，如果需要显示某个功能菜单，如： 显示分享到朋友圈 显示分享给朋友 12345wechatMgr.InitWeChat(&#123; menu_share_timeline: true[false], menu_share_appMessage: true[false]&#125;); 分享内容分享到朋友圈 object是一个对象字面量 forword_title：标题 forword_desc：描述 forword_link：跳转链接 forword_imgUrl：图片地址 fn1是成功分享之后的回调函数success(res) res 回调函数总对象 fn2是取消分享之后的回调函数cancel(res, forword) res 回调函数总对象 forword 当前分享内容对象 12wechatMgr.Forword([object],[fn1],[fn2]) 分享给朋友 object是一个对象字面量 forword_title：标题 forword_desc：描述 forword_link：跳转链接 forword_imgUrl：图片地址 fn1是成功分享之后的回调函数success(res) res 回调函数总对象 fn2是取消分享之后的回调函数cancel(res, forword) res 回调函数总对象 forword 当前分享内容对象 12wechatMgr.ForwordToFriend([object],[fn1],[fn2]) 和分享到朋友圈一样，ShareQQ、ShareWeibo、ShareQZone也是如此操作。在这里就不做赘述了。 获取地理位置 type默认为wgs84的gps坐标，如果要返回直接给openLocation用的火星坐标，可传入gcj02 fn是获取地理位置成功之后的回调函数success(res,latitude, longitude, speed, accuracy) res：回调总对象 latitude：经度 longitude：纬度 speed：速度 accuracy：精度 api这里没有给到cancel回调函数，如果需要此回调，可重写 12wechatMgr.GetLocation([type],[fn]) 获取网络状态 fn是成功获取当前网络状态之后的回调函数success(res, networkType) res：回调总对象 networkType：当前网络类型 12wechatMgr.GetNetWorkType(fn) 选择图片 fn是当前成功回调函数success(res, localIds) res：总回调对象 localIds：选定照片的本地ID列表，localId可以作为img标签的src属性显示图片 12wechatMgr.ChooseImg([fn]) 上传图片 imgLocalIds需要上传的图片的本地ID，由chooseImage接口获得 fn当前成功回调的函数success(res, serverId) res：回调总对象 serverId：返回图片的服务器端ID 12wechatMgr.UploadImage([imgLocalIds], [fn]) 预览图片 previewCurrentImg当前显示图片的http链接 previewUrls需要预览的图片http链接列表[] 12wechatMgr.PreviewImage([previewCurrentImg], [previewUrls]) 打开地图 res是一个对象包含 latitude：纬度，浮点数，范围为90 ~ -90 longitude：经度，浮点数，范围为180 ~ -180。 name：位置名 address：地址详细说明 scale：地图缩放级别,整形值,范围从1~28。默认为最大 infoUrl：在查看位置界面底部显示的超链接,可点击跳转 12wechatMgr.OpenLocation(res) 调取摄像头 fn是当前扫描成功之后的回调函数success(result) result：扫码返回的结果 123456789document.getElementById('btn1').onlick=function()&#123; wechatMgr.Scan(fn)&#125;document.getElementById('btn1').onlick=function()&#123; $.Scan(fn)&#125;$('#btn1').Scan(fn) 显示隐藏右上角菜单12345/**隐藏右上角菜单**/wechatMgr.HideOptionMenu();/**显示右上角菜单**/wechatMgr.ShowOptionMenu(); 微信卡券微信支付 object是当前支付对象字面量 timestamp：支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符 nonceStr：支付签名随机串，不长于 32 位 package：统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=*） signType：签名方式，默认为SHA1，使用新版支付需传入MD5 paySign：支付签名 fn是当前支付成功回调函数success(res, pay) res：当前支付回调总对象 pay：支付对象 1wechatMgr.ChooseWXPay([object],[fn]) 是否是微信浏览器 fn是当前成功回调函数success(isWeixinBro) isWeixinBro是否是微信浏览器boolean 1wechatMgr.IsWeChatBrower([fn]) 关闭微信窗口1wechatMgr.CloseWindow() 异常捕获 fn是当前异常捕获之后的回调函数success(res) res是异常信息 1wechatMgr.InitWxError([fn]) API可配置项debug是否打开debug调试，默认false baseapi_checkJsApi判断当前客户端是否支持指定的js接口，默认true baseapi_onMenuShareTimeline是否启用分享到朋友圈js接口，默认true baseapi_onMenuShareAppMessage是否启用分享给朋友js接口，默认true baseapi_onMenuShareQQ是否启用分享到QQjs接口，默认true baseapi_onMenuShareWeibo是否启用分享到微博js接口，默认true baseapi_hideMenuItems是否启用隐藏菜单js接口，默认true baseapi_showMenuItems是否启用显示菜单js接口，默认true baseapi_hideAllNonBaseMenuItem是否启用隐藏基础菜单js接口，默认true baseapi_showAllNonBaseMenuItem是否启用显示基础菜单js接口，默认true baseapi_hideOptionMenu是否启用隐藏普通菜单js接口，默认true baseapi_showOptionMenu是否启用显示普通菜单js接口，默认true baseapi_closeWindow是否启用关闭窗口js接口，默认true baseapi_scanQRCode是否启用扫描二维码js接口，默认true baseapi_startRecord是否启用录音js接口，默认true baseapi_stopRecord是否启用停止录音js接口，默认true baseapi_onVoiceRecordEnd是否启用录音结束js接口，默认true baseapi_playVoice是否启用播放录音js接口，默认true baseapi_pauseVoice是否启用暂停录音js接口，默认true baseapi_stopVoice是否启用停止录音js接口，默认true baseapi_onVoicePlayEnd是否启用播放停止js接口，默认true baseapi_uploadVoice是否启用上传录音js接口，默认true baseapi_downloadVoice是否启用下载录音js接口，默认true baseapi_chooseImage是否启用选择图片js接口，默认true baseapi_previewImage是否启用预览图片js接口，默认true, baseapi_uploadImage是否启用上传图片js接口，默认true baseapi_downloadImage是否启用下载图片js接口，默认true baseapi_translateVoice是否启用转换声音js接口，默认true baseapi_getNetworkType是否启用获取网络类型js接口，默认true baseapi_openLocation是否启用打开地图js接口，默认true baseapi_getLocation是否启用获取地理位置js接口，默认true baseapi_chooseWXPay是否启用微信支付js接口，默认true baseapi_openProductSpecificView是否启用跳转微信商品页js接口，默认true baseapi_addCard是否启用添加卡券js接口，默认true baseapi_chooseCard是否启用选择卡券js接口，默认true baseapi_openCard是否启用打开卡券js接口，默认true appId微信appid，可直接传递也可以通过api远程地址获取result.APPID timestamp时间戳，可直接传递也可以通过api远程地址获取result.TIMESTAMP nonceStr特定字符窜，可直接传递也可以通过api远程地址获取result.NONCESTR signature签名，可直接传递也可以通过api远程地址获取result.SIGNATURE access_tokentoken，可直接传递也可以通过api远程地址获取result.ACCESS_TOKEN menu_share_timeline分享到朋友圈，默认true menu_share_appMessage分享给朋友，默认true menu_share_favorite收藏，默认true menu_share_openWithSafari浏览器中打开，默认true menu_share_email邮件打开，默认true menu_share_qq分享到qq，默认true menu_share_QZone分享到qq空间，默认true menu_share_weiboApp分享到微博，默认true menu_share_copyUrl复制，默认true menu_share_setFont设置字体，默认true menu_share_readMode阅读模式，默认true menu_share_refresh刷新，默认true api远程api地址，本工具是使用ajax来交互数据的，并没有使用jsonp等跨域方式，所以最好你的api地址在服务器端已经开启了可以跨域的限制Access-Control-Allow-Origin=your domain#### facid业务标识#### typenum公众号类型 data提交的数据{}对象字面量 scanAuthUrl需要调取摄像头的页面，默认location.href hideOptionMenu是否隐藏菜单，默认true async是否异步，默认false type提交类型，默认post ContentType文档类型，默认application/x-www-form-urlencoded cache是否启用缓存，默认true FAQ调用api的方式有几种？1、jquery静态调用1234document.getElementById('btn1').onlick=function()&#123; $.Scan(fn)&#125; 2、jquery实例调用12$('#btn1').Scan(fn) 3、wechart对象调用1234document.getElementById('btn1').onlick=function()&#123; wechatMgr.Scan(fn)&#125; 如何调试debug1、使用微信开发这工具调试 2、在WeChart中启用debug为true即可 无法使用node模式加载？在npm是可以直接下载使用的，但是次此插件仅供在浏览器端使用，node端无法执行本插件。会抛出jquery_wechat_sdk requires a window with a document的异常 附录需要改善的地方1、每次调用都会从服务器端获取appid等信息，需要优化处理。2、处理signature、access_token需要模块化 外链地址1、微信官方文档2、jquery_wechat_sdk在npm上的地址3、jquery_wechat_sdk源码4、在线聊天地址 交流QQ群：596087259 ，使用疑问，开发，贡献代码请加群。]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Wechat</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端一键打包发布]]></title>
    <url>%2F2016%2F11%2F13%2F%E5%89%8D%E7%AB%AF%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[安装gulp全局安装 gulp 12$ npm install --global gulp 作为项目的开发依赖（devDependencies）安装 12$ npm install --save-dev gulp 创建gulpfile.js文件在项目根目录下创建一个名为 gulpfile.js 的文件： 1234gulp.task('default', function() &#123; // 将你的默认的任务代码放在这&#125;); 运行 gulp1$ gulp default 编译Less安装gulp-less 12$ npm install gulp-less gulp-rename --save-dev 12345678910less = require('gulp-less'),//rename = require('gulp-rename'), //文件重命名模块//编译Less并且压缩改名*.min.cssgulp.task('Less', function () &#123; gulp.src('src/css', &#123; base: '.' &#125;) //该任务针对的文件 .pipe(rename(&#123; suffix: '.min' &#125;)) .pipe(less()) //该任务调用的模块 .pipe(gulp.dest('src/css'));&#125;); 使用方法 12$ gulp Less 编译Less&amp;压缩改名//编译Less并且压缩改名*.min.css 1234567gulp.task('Less2', function () &#123; gulp.src('src/css', &#123; base: '.' &#125;) //该任务针对的文件 .pipe(rename(&#123; suffix: '.min' &#125;)) .pipe(less()) //该任务调用的模块 .pipe(cssmin()) //该任务调用的模块 .pipe(gulp.dest('src/css')); //将会在src/css下生成index.css&#125;); 使用方法 12$ gulp Less2 压缩&amp;合并Css&amp;改名1$ npm install cssmin concat --save-dev 123cssmin = require('gulp-minify-css'), //压缩cssconcat = require('gulp-concat'), //文件合并 12345678//压缩合并Css改名*.min.cssgulp.task('CssConcat', function () &#123; gulp.src('src/css', &#123; base: '.' &#125;) .pipe(rename(&#123; suffix: '.min' &#125;)) .pipe(cssmin()) .pipe(concat('newname')) .pipe(gulp.dest('src/css'))&#125;); 使用方法 12$ gulp CssConcat 压缩html安装gulp-htmlmin 1$ npm install gulp-htmlmin --save-dev 1htmlmin = require('gulp-htmlmin'), 123456789101112131415gulp.task('Html', function () &#123; var options = &#123; removeComments: true, collapseWhitespace: true, collapseBooleanAttributes: true, removeEmptyAttributes: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, minifyJS: true, minifyCSS: true &#125;; return gulp.src('src/html', &#123; base: '.' &#125;) .pipe(htmlmin(options)) .pipe(gulp.dest('src/html'))&#125;); 使用 1$ gulp Html 压缩jpg、png图片安装gulp-imagemin 12$ npm install gulp-imagemin gulpif --save-dev 12imagemin = require('gulp-imagemin'), //图片压缩gulpif = require('gulp-if'), 12345gulp.task('Image', function () &#123; return gulp.src('src/images', &#123; base: '.' &#125;) .pipe(gulpif([true,false], imagemin())) .pipe(gulp.dest('src/images'));&#125;); 使用 1$ gulp Image 压缩JS安装gulp-uglify 1$ npm install gulp-uglify --save-dev 1uglify = require('gulp-uglify'), //混淆js 12345gulp.task('JS', function () &#123; return gulp.src('src/js', &#123; base: '.' &#125;) .pipe(uglify()) .pipe(gulp.dest('src/js'));&#125;); 使用方法 1$ gulp JS 到目前为止，已经基本实现gulp打包压缩前端代码的核心功能，但是这远远还不够。因为在日常开发过程中我们会面临各种前端优化问题，比如缓存、发布、打包所带来的一系列问题。 一般情况下，我们前端开发就会想了解大公司是如何打包的？，在文章中，@张云龙有详细的介绍各种前端工程化，我就不做赘述了。如果你已经看完大公司是如何打包的？那么，你又没有想自己来试一试的想法呢。OK，我们来了解一下吧~~ 既然如此，我们来看一下如何解决以下问题： 先发布应用（html）还是先发布资源（css、js、png、jpg等）？ 如何实现资源精确缓存？ 如何让浏览器主动放弃已经弃用的缓存？ 如何把资源放到CDN节点上？ 我们先把问题放一边，接下来继续改造我们的gulpfile.js文件 添加hash后缀12$ npm install gulp-rev --save-dev 12rev = require('gulp-rev'), //更改hash版本号 1234567//Css添加版本号gulp.task('RevCss', function () &#123; return gulp.src('src/css') .pipe(rev()) .pipe(rev.manifest()) .pipe(gulp.dest('./build' + '/rev/css'));&#125;); 使用 12$ gulp RevCss 执行完成之后这次会有不一样的地方，会在rev/css目录下面会生成一个rev-manifest.json的文件，这个文件将作为替换原始原件的依据并且打包到当前自定义目录./build/rev下，当然这个hash就是当前文件内容的哈希值 123456&#123; "css/animate.css": "css/animate-7a37992a94.css", "css/front.css": "css/front-26561396d8.css", "css/index.css": "css/index-38b95d80bb.css", "script/plugins/layer_mobile/need/layer.css": "script/plugins/layer_mobile/need/layer-f6c02b5edb.css"&#125; 依此类推同理可写出js/png/jpg的哈希任务，如果文件更改，发布的时候哈希值自然就会发生改变，发布到服务器之后，html页面则会自动放弃以前失效的缓存。 精确管理缓存精确管理缓存，顾名思义就是在html页面或者css页面中引用的资源文件加上hash后缀，并且自动替换成当前指定的文件，那现在就要用到文章上面提到的rev-manifest.json文件。 12$ npm install gulp-rev-collector --save-dev 12revCollector = require('gulp-rev-collector'), 123456789gulp.task('RevHtml', function () &#123; return gulp.src(['./build/rev/**/*.json', './build/app/**/*.html']) .pipe(revCollector( &#123; replaceReved: true &#125; )) .pipe(gulp.dest('./build' + '/app'));&#125;); 使用方法 12$ gulp RevHtml 执行完成之后再回到./build/app/看当前html页面指向的css是否已经变为css/index-38b95d80bb.css，如果是则恭喜你成功了，如果没有，你还需要斟酌一下~~至于其他的css中有的图片或者html页面中有的js/image则都是一个道理，可以葫芦画瓢写多个task执行即可 把资源放到CDN节点上放到CDN节点上无非就是更改已经发布好的源文件的资源文件链接，这里使用替换即可，也可使用其他方式实现。 12$ npm install gulp-replace --save-dev 12replace = require('gulp-replace'), 1234567gulp.task('CDN', function () &#123; return gulp.src('./build/app/**/*.html') .pipe(replace('../../static/css', 'http://cdn.com/css')) .pipe(replace('../../static/js', 'http://cdn.com/js')) .pipe(replace('../../static/image', 'http://cdn.com/image') .pipe(gulp.dest('./build' + '/app'));&#125;); 使用方法 12$ gulp CDN 同理，在css文件或者其他文件中有引用资源文件就再写几个对应的task即可。 清除发布目录OK，在执行之前需要清理一下当前发布目录./build 1$ npm install gulp-clean --save-dev 1clean = require('gulp-clean'), //删除 12345//清空发布目录gulp.task('clean', function () &#123; return gulp.src('./build' + '/*', &#123; read: false &#125;) .pipe(clean());&#125;); 使用方法 12$ gulp clean 执行队列那么，问题来了。这么多的task难道要一个一个的手动执行么？当然可以一次性搞定撒，要不然怎么叫一键打包发布呢？ 12345//默认执行gulp.task('build', function (cb) &#123; runSequence('clean',task1', 'task2','……','zip', cb);&#125;); 只需执行build即可 12$ gulp build 打包发布OK,既然是一键打包发布，那么如何打包发布呢？那就要使用zip ftp了 12$ npm install gulp-zip gulp-ftp --save-dev 12zip = require('gulp-zip'),ftp = require('gulp-ftp'), 123456//打包gulp.task('zip', function () &#123; gulp.src(fileConfig.output.dist + '/**/**') .pipe(zip('name-20171011.zip')) .pipe(gulp.dest('./build/build_zip'));&#125;); 123456789101112//上传gulp.task('ftp', function () &#123; console.log('努力上传中...'); gulp.src("./build/build_zip/**") .pipe(ftp(&#123; host: 'ip', port: port, user: 'name', pass: 'pwd', remotePath: "projectname/20170101/" &#125;));&#125;); 结束语书接上文，在文章的中段，我抛出了几个问题，通读全文你是否已经有了答案？前端优化已经不再是html css js image简单问题，而是一个工程化问题： 配置超长时间的本地缓存 —— 节省带宽，提高性能 采用内容摘要作为缓存更新依据 ——精确的缓存控制 静态资源CDN部署 ——优化网络请求 资源发布路径实现非覆盖式发布 —— 平滑升级 当然，这个只是使用gulp来自己编写，也可使用fis来进行系统操作。 中文APIhttp://www.gulpjs.com.cn/docs/]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速理解模块化加载]]></title>
    <url>%2F2016%2F11%2F13%2F%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Javascript模块化在了解这些规范之前，还是先了解一下什么是模块化。 模块化是指在解决某一个复杂问题或者一系列的杂糅问题时，依照一种分类的思维把问题进行系统性的分解以之处理。模块化是一种处理复杂系统分解为代码结构更合理，可维护性更高的可管理的模块的方式。可以想象一个巨大的系统代码，被整合优化分割成逻辑性很强的模块时，对于软件是一种何等意义的存在。对于软件行业来说：解耦软件系统的复杂性，使得不管多么大的系统，也可以将管理，开发，维护变得“有理可循”。 还有一些对于模块化一些专业的定义为：模块化是软件系统的属性，这个系统被分解为一组高内聚，低耦合的模块。那么在理想状态下我们只需要完成自己部分的核心业务逻辑代码，其他方面的依赖可以通过直接加载被人已经写好模块进行使用即可。 首先，既然是模块化设计，那么作为一个模块化系统所必须的能力： 定义封装的模块。 定义新模块对其他模块的依赖。 可对其他模块的引入支持。 好了，思想有了，那么总要有点什么来建立一个模块化的规范制度吧，不然各式各样的模块加载方式只会将局搅得更为混乱。那么在JavaScript中出现了一些非传统模块开发方式的规范 CommonJS的模块规范，AMD（Asynchronous Module Definition），CMD（Common Module Definition）等。 CommonJS CommonJS是服务器端模块的规范，Node.js采用了这个规范。 根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。 例如： 1234567891011121314151617181920// foobar.js//私有变量var test = 123;//公有方法function foobar () &#123; this.foo = function () &#123; // do someing ... &#125; this.bar = function () &#123; //do someing ... &#125;&#125;//exports对象上的方法和变量是公有的var foobar = new foobar();exports.foobar = foobar; 1234//require方法默认读取js文件，所以可以省略js后缀var test = require('./boobar').foobar;test.bar(); CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD CMD 解决方案。 CMD和SeaJS CMD是SeaJS 在推广过程中对模块定义的规范化产出 对于依赖的模块AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不通过）。 CMD推崇依赖就近，AMD推崇依赖前置。 1234567891011121314151617181920212223//AMDdefine(['./a','./b'], function (a, b) &#123; //依赖一开始就写好 a.test(); b.test();&#125;);//CMDdefine(function (requie, exports, module) &#123; //依赖可以就近书写 var a = require('./a'); a.test(); ... //软依赖 if (status) &#123; var b = requie('./b'); b.test(); &#125;&#125;); UMD UMD是AMD和CommonJS的糅合 AMD模块以浏览器第一的原则发展，异步加载模块。CommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。这迫使人们又想出另一个更通用的模式UMD（Universal Module Definition）。希望解决跨平台的解决方案。 UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。 1234567891011121314(function (window, factory) &#123; if (typeof exports === 'object') &#123; module.exports = factory(); &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; define(factory); &#125; else &#123; window.eventUtil = factory(); &#125;&#125;)(this, function () &#123; //module ...&#125;); AMD和RequireJSAMDAMD是“Asynchronous Module Definition”的缩写，意思就是”异步模块定义”.AMD设计出一个简洁的写模块API： 1define(id?, dependencies?, factory); 第一个参数 id 为字符串类型，表示了模块标识，为可选参数。若不存在则模块标识应该默认定义为在加载器中被请求脚本的标识。如果存在，那么模块标识必须为顶层的或者一个绝对的标识。 第二个参数，dependencies ，是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。 第三个参数，factory，是一个需要进行实例化的函数或者一个对象。 通过参数的排列组合，这个简单的API可以从容应对各种各样的应用场景，如下所述。 定义无依赖的模块123456define( &#123; add : function( x, y )&#123; return x + y ; &#125;&#125; ); 定义有依赖的模块12345678define(["alpha"], function( alpha )&#123; return &#123; verb : function()&#123; return alpha.verb() + 1 ; &#125; &#125;&#125;); 定义数据对象模块12345define(&#123; users: [], members: []&#125;); 具名模块12345678define("alpha", [ "require", "exports", "beta" ], function( require, exports, beta )&#123; export.verb = function()&#123; return beta.verb(); // or: return require("beta").verb(); &#125;&#125;); 包装模块1234567define(function(require, exports, module) &#123; var a = require('a'), b = require('b'); exports.action = function() &#123;&#125;;&#125; ); 不考虑多了一层函数外，格式和Node.js是一样的：使用require获取依赖模块，使用exports导出API。 除了define外，AMD还保留一个关键字require。require 作为规范保留的全局标识符，可以实现为 module loader，也可以不实现。 模块加载12require([module], callback) AMD模块化规范中使用全局或局部的require函数实现加载一个或多个模块，所有模块加载完成之后的回调函数。 module：是一个数组，里面的成员就是要加载的模块； callback：是模块加载完成之后的回调函数。 1234require(['math'], function(math) &#123; math.add(2, 3);&#125;); RequireJS RequireJS 是一个前端的模块化管理的工具库，遵循AMD规范，它的作者就是AMD规范的创始人 James Burke。所以说RequireJS是对AMD规范的阐述一点也不为过。 RequireJS 的基本思想为：通过一个函数来将所有所需要的或者说所依赖的模块实现装载进来，然后返回一个新的函数（模块），我们所有的关于新模块的业务代码都在这个函数内部操作，其内部也可无限制的使用已经加载进来的以来的模块。 1&lt;script data-main='scripts/main' src='scripts/require.js'&gt;&lt;/script&gt; 那么scripts下的main.js则是指定的主代码脚本文件，所有的依赖模块代码文件都将从该文件开始异步加载进入执行。 define用于定义模块，RequireJS要求每个模块均放在独立的文件之中。按照是否有依赖其他模块的情况分为独立模块和非独立模块。 独立模块，不依赖其他模块。1234define(&#123; method1: function()&#123;&#125;, method2: function()&#123;&#125;&#125;); 等价于 123456define(function() &#123; return &#123; method1: function()&#123;&#125;, method2: function()&#123;&#125; &#125;&#125;); 非独立模块，对其他模块有依赖。123define([ 'module1', 'module2' ], function(m1, m2) &#123; ...&#125;); 12345define(function(require) &#123; var m1 = require('module1'), m2 = require('module2'); ...&#125;); 简单看了一下RequireJS的实现方式，其 require 实现只不过是提取 require 之后的模块名，将其放入依赖关系之中。 在require进行调用模块时，其参数与define类似。 1234require(['foo', 'bar'], function(foo, bar) &#123; foo.func(); bar.func();&#125; ); 在加载 foo 与 bar 两个模块之后执行回调函数实现具体过程。 当然还可以如之前的例子中的，在define定义模块内部进行require调用模块 12345define(function(require) &#123; var m1 = require( 'module1' ), m2 = require( 'module2' ); ...&#125;); define 和 require 这两个定义模块，调用模块的方法合称为AMD模式，定义模块清晰，不会污染全局变量，清楚的显示依赖关系。AMD模式可以用于浏览器环境并且允许非同步加载模块，也可以按需动态加载模块。 文章参考来源 @我是豆腐不是渣segmentfault.com/a/1190000004873947]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>AMD</tag>
        <tag>CMD</tag>
        <tag>CommonJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON WEB TOKEN]]></title>
    <url>%2F2016%2F10%2F31%2FJSON-WEB-TOKEN%2F</url>
    <content type="text"><![CDATA[JSONWebToken APIAn implementation of JSON Web Tokens.This was developed against draft-ietf-oauth-json-web-token-08. It makes use of node-jws. 安装12$ npm install jsonwebtoken 版本迁移From v7 to v8 用法API12jwt.sign(payload, secretOrPrivateKey, [options, callback]) (Asynchronous) If a callback is supplied, the callback is called with the err or the JWT. (Synchronous) Returns the JsonWebToken as string payload could be an object literal, buffer or string. Please note that exp is only set if the payload is an object literal. secretOrPrivateKey is a string, buffer, or object containing either the secret for HMAC algorithms or the PEM encoded private key for RSA and ECDSA. In case of a private key with passphrase an object { key, passphrase } can be used (based on crypto documentation), in this case be sure you pass the algorithm option. @Auth0github.com/xulayen/node-jsonwebtoken sign with default (HMAC SHA256) 12345// sign with default (HMAC SHA256)var jwt = require('jsonwebtoken');var token = jwt.sign(&#123; foo: 'bar' &#125;, 'secret');console.log(token) sign with RSA SHA256 123456789// sign with RSA SHA256var cert = fs.readFileSync('private.key'); // get private keyvar token = jwt.sign(&#123; foo: 'bar' &#125;, cert, &#123; algorithm: 'RS256'&#125;);// sign asynchronouslyjwt.sign(&#123; foo: 'bar' &#125;, cert, &#123; algorithm: 'RS256' &#125;, function(err, token) &#123; console.log(token);&#125;); TOKEN失效The standard for JWT defines an exp claim for expiration. The expiration is represented as a NumericDate:A JSON numeric value representing the number of seconds from 1970-01-01T00:00:00Z UTC until the specified UTC date/time, ignoring leap seconds. This is equivalent to the IEEE Std 1003.1, 2013 Edition [POSIX.1] definition “Seconds Since the Epoch”, in which each day is accounted for by exactly 86400 seconds, other than that non-integer values can be represented. See RFC 3339 [RFC3339] for details regarding date/times in general and UTC in particular.This means that the exp field should contain the number of seconds since the epoch. @Auth0github.com/xulayen/node-jsonwebtoken 产生一个token1小时后失效： 12345jwt.sign(&#123; exp: Math.floor(Date.now() / 1000) + (60 * 60), data: 'foobar'&#125;, 'secret'); 另外一个方式产生token并且有失效机制 12345678910jwt.sign(&#123; data: 'foobar'&#125;, 'secret', &#123; expiresIn: 60 * 60 &#125;);//or even better:jwt.sign(&#123; data: 'foobar'&#125;, 'secret', &#123; expiresIn: '1h' &#125;); 验证tokentoken是一个JsonWebToken字符窜 (Asynchronous) If a callback is supplied, function acts asynchronously. The callback is called with the decoded payload if the signature is valid and optional expiration, audience, or issuer are valid. If not, it will be called with the error. (Synchronous) If a callback is not supplied, function acts synchronously. Returns the payload decoded if the signature is valid and optional expiration, audience, or issuer are valid. If not, it will throw the error. @Auth0github.com/xulayen/node-jsonwebtoken secretOrPublicKey是一个字符窜或者HMAC algorithms缓冲区中的任何一个PEM编码了RSA和ECDSA的公钥。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//verify a token symmetric - synchronousvar decoded = jwt.verify(token, 'secret');console.log(decoded.foo) // bar// verify a token symmetricjwt.verify(token, 'shhhhh', function(err, decoded) &#123; console.log(decoded.foo) // bar&#125;);// invalid token - synchronoustry &#123; var decoded = jwt.verify(token, 'wrong-secret');&#125; catch(err) &#123; // err&#125;// invalid tokenjwt.verify(token, 'wrong-secret', function(err, decoded) &#123; // err // decoded undefined&#125;);// verify a token asymmetricvar cert = fs.readFileSync('public.pem'); // get public keyjwt.verify(token, cert, function(err, decoded) &#123; console.log(decoded.foo) // bar&#125;);// verify audiencevar cert = fs.readFileSync('public.pem'); // get public keyjwt.verify(token, cert, &#123; audience: 'urn:foo' &#125;, function(err, decoded) &#123; // if audience mismatch, err == invalid audience&#125;);// verify issuervar cert = fs.readFileSync('public.pem'); // get public keyjwt.verify(token, cert, &#123; audience: 'urn:foo', issuer: 'urn:issuer' &#125;, function(err, decoded) &#123; // if issuer mismatch, err == invalid issuer&#125;);// verify jwt idvar cert = fs.readFileSync('public.pem'); // get public keyjwt.verify(token, cert, &#123; audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' &#125;, function(err, decoded) &#123; // if jwt id mismatch, err == invalid jwt id&#125;);// verify subjectvar cert = fs.readFileSync('public.pem'); // get public keyjwt.verify(token, cert, &#123; audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' &#125;, function(err, decoded) &#123; // if subject mismatch, err == invalid subject&#125;);// alg mismatchvar cert = fs.readFileSync('public.pem'); // get public keyjwt.verify(token, cert, &#123; algorithms: ['RS256'] &#125;, function (err, payload) &#123; // if token alg != RS256, err == invalid signature&#125;); 解码token12jwt.decode(token [, options]) token is the JsonWebToken string options: json: force JSON.parse on the payload even if the header does not contain “typ”:”JWT”. complete: return an object with the decoded payload and header. Example 12345678// get the decoded payload ignoring signature, no secretOrPrivateKey neededvar decoded = jwt.decode(token);// get the decoded payload and headervar decoded = jwt.decode(token, &#123;complete: true&#125;);console.log(decoded.header);console.log(decoded.payload) token失效异常TokenExpiredError Thrown error if the token is expired. Error object: name: ‘TokenExpiredError’ message: ‘jwt expired’ expiredAt: [ExpDate] 123456789101112jwt.verify(token, 'wrongsecret', function(err, decoded) &#123; if (err) &#123; /* err = &#123; name: 'TokenExpiredError', message: 'jwt expired', expiredAt: 1408621000 &#125; */ &#125;&#125;); JsonWebTokenError Error object: name: JsonWebTokenError message: ‘jwt malformed’ ‘jwt signature is required’ ‘invalid signature’ ‘jwt audience invalid. expected: [OPTIONS AUDIENCE]’ ‘jwt issuer invalid. expected: [OPTIONS ISSUER]’ ‘jwt id invalid. expected: [OPTIONS JWT ID]’ ‘jwt subject invalid. expected: [OPTIONS SUBJECT]’ 1234567891011jwt.verify(token, 'woringsecret', function(err, decoded) &#123; if (err) &#123; /* err = &#123; name: 'JsonWebTokenError', message: 'jwt malformed' &#125; */ &#125;&#125;);]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>JWT</tag>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs搭建web服务]]></title>
    <url>%2F2016%2F10%2F25%2Fnodejs%E6%90%AD%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[安装nodejs、npm安装成功之后，使用命令测试是否成功： 1234$ node -vv6.10.2 1234$ npm -v5.3.0 初始化项目配置在chat文件夹下执行初始化命令来获取package.json文件，如果你自己能记住也是可以手写的 12345678910111213141516171819202122232425$ npm initpackage name: (20171022)version: (1.0.0)description:entry point: (index.js)test command:git repository:keywords:author:license: (ISC)About to write to C:\Users\Administrator\Desktop\20171022\package.json:&#123; "name": "20171022", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC"&#125; web服务需要引用的模块http模块(http协议)12$ npm install http --save-dev 12var url = require('http'); Node中提供了http模块，其中封装了高效的http服务器和http客户端http.server是一个基于事件的HTTP服务器，内部是由c++实现的，接口由JavaScript封装http.request是一个HTTP客户端工具。用户向服务器发送数据。 @Helios_nannanblog.csdn.net/woshinannan741/article/details/51357464 url模块(url解析)12$ npm install url --save-dev 1var url = require('url'); This module has utilities for URL resolution and parsing meant to have feature parity with node.js core url module. @npmwww.npmjs.com/package/url fs模块(文件系统)12$ npm install fs --save-dev 1var fs = require("fs"); Node.js 文件系统封装在 fs 模块是中，它提供了文件的读取、写入、更名、删除、遍历目录、链接等POSIX 文件系统操作。 与其他模块不同的是，fs 模块中所有的操作都提供了异步的和 同步的两个版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。我们以几个函数为代表，介绍 fs 常用的功能，并列出 fs 所有函数 的定义和功能。 @平凡www.cnblogs.com/pingfan1990/p/4707317.html path模块(路径解析)12$ npm install path --save-dev 1var path = require("path"); This is an exact copy of the NodeJS ’path’ module published to the NPM registry. @npmwww.npmjs.com/package/path 构建一个基于nodejs的web服务器新建一个index.html 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;Sample Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt; 新建一个webserver.js 1234567891011121314151617181920212223242526272829303132333435var http = require('http');var fs = require('fs');var url = require('url');// 创建服务器http.createServer( function (request, response) &#123; // 解析请求，包括文件名 var pathname = url.parse(request.url).pathname; // 输出请求的文件名 console.log("Request for " + pathname + " received."); // 从文件系统中读取请求的文件内容 fs.readFile(pathname.substr(1), function (err, data) &#123; if (err) &#123; console.log(err); // HTTP 状态码: 404 : NOT FOUND // Content Type: text/plain response.writeHead(404, &#123;'Content-Type': 'text/html'&#125;); &#125;else&#123; // HTTP 状态码: 200 : OK // Content Type: text/plain response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); // 响应文件内容 response.write(data.toString()); &#125; // 发送响应数据 response.end(); &#125;);&#125;).listen(8081);// 控制台会输出以下信息console.log('Server running at http://127.0.0.1:8081/'); 安装用到的模块到本地项目中： 12345678$ npm install path --save-dev$ npm install fs --save-dev$ npm install http --save-dev$ npm install url --save-dev 安装成功之后执行命令 12$ node webserver 在浏览器起中打开：http://127.0.0.1:8081/ 即可查看效果： ExpressExpress is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. @expressexpressjs.com express API地址：http://www.expressjs.com.cn/4x/api.html 创建一个文件夹express+nodejs，执行初始化项目操作，在项目上安装express 12$ npm install express --save 并且新建index.js、index.html文件 123456789var express = require('express');var app = express();app.get('/', function(req, res)&#123; res.send('hello world2');&#125;);app.listen(3000); 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;Sample Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt; 在命令行中执行：12$ node index 如果提示listen EADDRINUSE :::3000就说明端口被占用了，可以换成其他端口 123456789101112Error: listen EADDRINUSE :::3000 at Object.exports._errnoException (util.js:1018:11) at exports._exceptionWithHostPort (util.js:1041:20) at Server._listen2 (net.js:1262:14) at listen (net.js:1298:10) at Server.listen (net.js:1394:5) at EventEmitter.listen (E:\工作\workpace\Express\node_modules\express\lib\application.js:618:24) at Object.&lt;anonymous&gt; (E:\工作\workpace\Express\index.js:8:5) at Module._compile (module.js:570:32) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) 在浏览器中打开 http://localhost:3000/ 使用Express加载模版并输出数据未完待续……]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行代码搭建Hexo站点]]></title>
    <url>%2F2016%2F10%2F23%2F%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%90%AD%E5%BB%BAHexo%E7%AB%99%E7%82%B9%2F</url>
    <content type="text"><![CDATA[初始化Hexo模版引擎 一行代码快速搭建Hexo.NexT主题网站，来吧，趁热打铁一起快速进入学习吧！ 执行安装进入本机E盘Blog目录下 第一步，安装下载Hexo模版，即初始化Hexo模版 第二步，进入blog文件夹，执行安装依赖包 第三步，启动Hexo服务 第四步，打开控制台给出的http地址，http://localhost:4000/ 12345678910npm install hexo-cli -ghexo init blogcd blognpm installhexo server 如果你没有安装npm，请先执行下载安装 安装成功执行 123npm -v 执行以上步骤之后在浏览器中键入http://localhost:4000 即可看到一个初始状态的模版 修改测试端口号如果需要修改端口4000，可以在node-modules文件夹下找到hexo-server模块中的index.js: 12345678910111213141516/* global hexo */&apos;use strict&apos;;var assign = require(&apos;object-assign&apos;);hexo.config.server = assign(&#123; port: 5000,//自行修改端口号 log: false, ip: &apos;0.0.0.0&apos;, compress: false, header: true&#125;, hexo.config.server); 修改之后重新执行hexo server即可: 网站基础配置显示或隐藏Menu菜单在修改菜单之前你首先要弄清楚当前网站使用的皮肤是哪一个，打开网站根目录 config_yml12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 其中landscape就是你的皮肤框架 然后在网站根目录找到themes/landscape这里面就会有你菜单想的配置，同时这里面也有一个 config_yml，为了区分，我们索性把站点下的配置文件称为站点配置yml，皮肤框架下的配置文件称之为皮肤配置yml OK，打开皮肤配置yml你会看到一些简短的配置，其中第一条就是我们的菜单栏配置 12345# Headermenu: Home: / Archives: /archives 修改Home为主菜单，修改Archives为 文章，刷新浏览器http://localhost:5000 即可看到效果 配置站点基础信息打开站点配置yml 1234567# Sitetitle: 标题subtitle: 副标题description: 描述author: 作者language: zh-Hanstimezone: 刷新浏览器 http://localhost:5000 设置rss在站点根目录执行安装hexo-generator-feed 12npm install hexo-generator-feed --save-dev 在站点配置yml中配置插件，为了快速的找到配置项，可以放到文件的结尾 1234567plugins: hexo-generator-feedfeed: type: atom ##feed类型 atom或者rss2 path: atom.xml ##feed路径 limit: 20 ##feed文章最小数量 点击RSS按钮，会出现如下提示，前提是你的浏览器有rss功能，我本地使用的是rss feed reader： 设置本地全局搜索安装下载hexo-generator-searchdb模块12npm install hexo-generator-searchdb --save-dev 站点配置yml需要配置 123456search: path: search.xml field: post format: html limit: 10000 皮肤配置yml需要配置 123local_search: enable: true 当然你会发现并没有起作用，这是因为当前landscape并不支持本地搜索，后续将介绍NexT主题 使用命令生成静态文件您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。生成的文件在网站public目录下 12hexo generate --deployhexo deploy --generate 可缩写为： 12hexo g -dhexo d -g NexT主题下载安装NexT模版在github上下载NexT主题源码 把NexT主题源码的源码整个复制到你的站点目录下的themes/next目录下 修改站点配置yml来更改主题文章上面有讲到，当前我们的主题使用的是landscape需要修改为next 重新启动服务 刷新页面查看效果 学习并使用NexT主题配置打开next的皮肤配置yml，你会看到很多我们不明白的配置项，根据注释可以读出其中配置的含义。 根据语言配置菜单栏语言打开next皮肤配置yml文件，找到languages文件夹 点开zh-Hans.yml其中的配置项就是已经翻译的文本，网站会根据你站点配置yml中的语言配置来去读取对应的语言文件 打开你next皮肤配置yml你会看到菜单栏基础配置： 12345678910menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 发现home和archives菜单是开启的，现在我们全部开启，只需要去掉前面的#，刷新浏览器 12345678910menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive schedule: /schedule/ || calendar sitemap: /sitemap.xml || sitemap commonweal: /404/ || heartbeat 尝试修改站点配置yml语言，重启服务后刷新浏览器 12language: zh-tw 配置站内搜索安装下载hexo-generator-searchdb模块12npm install hexo-generator-searchdb --save-dev 站点配置yml需要配置 123456search: path: search.xml field: post format: html limit: 10000 皮肤配置yml需要配置 123local_search: enable: true 配置rss配置同见 2.3. 设置rss 配置标签(tags)添加标签其实就是在你的source文件夹下新建一个page页面而已，比如菜单上的tags和about或者categories都是一样的，执行命令 12hexo new page "tags" 会在source目录下生成一个对应的文件夹，其中有index.md文件，打开会看到一些基础配置： 12345---title: tagsdate: 2017-10-24 12:02:51--- 配置分类(categories)12hexo new page "categories" 会在source目录下生成一个对应的文件夹，其中有index.md文件，打开会看到一些基础配置： 1234---title: categoriesdate: 2017-10-24 12:02:51--- 配置站点基础信息配置头像在next皮肤配置yml中可以配置远程地址，也可以是本地资源地址 12345# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: 头像地址 配置站点描述在站点配置yml文件中，找到menu/description就是当前站点的描述 12description: 站点描述 配置第三方跳转链接在next皮肤配置yml中，找到social配置项 12345678910111213social: GitHub: https://github.com/yourname || github E-Mail: mailto:yourname@163.com || envelope QQ: http://wpa.qq.com/msgrd?v=3&amp;uin=yourqq&amp;site=在线客服&amp;menu=yes || qq #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 友情链接在next皮肤配置yml中，找到links配置项 12345678links_icon: linklinks_title: Linkslinks_layout: inlinelinks: friend1: friend2: friend3: 配置阅读次数（使用第三方服务）leancloud作为装逼神器确实不错，可以随意修改当前文章的阅读次数 12345678# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.# 使用第三方服务 LeanCloud 查看文章阅读量leancloud_visitors: enable: true app_id: app_key: 配置评论（使用第三方服务）在disqus官网 http://www.disqus.com 注册一个帐号添加应用之后可获得一个名称，作为你的shortname 123456# Disqusdisqus: enable: true shortname: 你的名称 count: true 配置站点统计（使用第三方服务）百度站点统计 http://tongji.baidu.com/web/welcome/login 1234# Baidu Analytics ID# 注意： baidu_analytics 不是你的百度 id 或者 百度统计 idbaidu_analytics: 327573ae29bff3e49a0152fd0be5e1c2 当前文章是否启用评论配置如果不需要当前页面或这文章不启用评论，则只需要添加以下配置： 123456---title: tagsdate: 2017-10-24 12:02:51comments: false--- 自定义配置在每个文章的最后加上版权声明 新建 passage-end-tag.swig 文件 在路径 \themes\next\layout\_macro中添加passage-end-tag.swig文件，其内容可以自定义： 12345678910111213141516171819&#123;% if theme.passage_end_tag.enabled %&#125;&lt;div&gt;&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------ 本文结束 ------&lt;/div&gt;&lt;br/&gt;&lt;ul class="post-copyright" style="margin: 2em 0 0; padding: 0.5em 1em;border-left: 3px solid #ff1700;background-color: #f9f9f9;list-style: none; "&gt; &lt;li class="post-copyright-author"&gt; &lt;strong&gt;本文作者：&lt;/strong&gt; Xu Layen &lt;/li&gt; &lt;li class="post-copyright-license"&gt; &lt;strong&gt;版权声明： &lt;/strong&gt; 本博客所有文章除特别声明外，转载请注明出处！ &lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&#123;% endif %&#125; 修改 post.swig 文件在\themes\next\layout\_macro\post.swig中，post-body之后，post-footer之前添: 1234&#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125;&#123;% endif %&#125; 在next主题配置yml中添加字段 1234# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 结束语跟着我的步骤可以很快的搭建一个属于自己的博客站点，当然hexo.next远远不知这些配置项，有兴趣的同学可以自己看看里面的配置。这篇文章为什么叫一行代码搭建hexo博客呢，啊哈哈哈，不这样也不会有人看哇，懂hexo的人就不用看了，高手勿喷~另外可以使用翻墙软件在下方评论，写下你想说的话，没有翻墙的，可以直接在站点概述中qq我或者e-mail我都可以。祝，早新手早日玩转hexo博客，这是 博主 的博客，文章不定期更新 NexT官网地址]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
